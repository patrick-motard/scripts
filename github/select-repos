#!/bin/bash

# Interactive repo selector for PR watching
# Usage: select-repos [--days N]
#   --days: number of days to look back for commit history (default: 90)
#
# Saves selected repos to ~/.config/gh-pr-select/repos.txt

CONFIG_DIR="${HOME}/.config/gh-pr-select"
CONFIG_FILE="${CONFIG_DIR}/repos.txt"
DAYS_BACK=90

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --days)
            DAYS_BACK="$2"
            shift 2
            ;;
        --days=*)
            DAYS_BACK="${1#*=}"
            shift
            ;;
        *)
            shift
            ;;
    esac
done

# Check for required commands
if ! command -v fzf &> /dev/null; then
    echo "Error: fzf is not installed" >&2
    exit 1
fi

if ! command -v gh &> /dev/null; then
    echo "Error: gh is not installed" >&2
    exit 1
fi

# Calculate date for commit search
if [[ "$OSTYPE" == "darwin"* ]]; then
    DATE_FILTER=$(date -u -v-${DAYS_BACK}d +"%Y-%m-%d")
else
    DATE_FILTER=$(date -u -d "${DAYS_BACK} days ago" +"%Y-%m-%d")
fi

# Get authenticated user
USERNAME=$(gh api user --jq '.login' 2>/dev/null)
if [[ -z "$USERNAME" ]]; then
    echo "Error: Unable to get GitHub username. Check gh auth status." >&2
    exit 1
fi

echo "Finding repos you've worked in recently..." >&2

# Collect all repos
REPOS_LIST=$(mktemp)

# Get personal repos
echo "Checking personal repos..." >&2
gh repo list --json nameWithOwner,pushedAt --limit 50 2>/dev/null | \
    jq -r '.[] | "\(.nameWithOwner)\t\(.pushedAt[:10])\tpersonal"' >> "$REPOS_LIST"

# Get organization repos where user has committed
ORGS=$(gh api user/orgs --jq '.[].login' 2>/dev/null)
for ORG in $ORGS; do
    echo "Checking ${ORG} org..." >&2

    # Check if we can access this org (SAML check)
    ORG_CHECK=$(gh api "orgs/${ORG}" 2>&1)
    if echo "$ORG_CHECK" | grep -qi "SAML enforcement\|OAuth token access"; then
        echo "  Skipping ${ORG} - SAML authorization required" >&2
        continue
    fi

    gh api "search/commits?q=org:${ORG}+author:${USERNAME}+committer-date:>${DATE_FILTER}&sort=committer-date&order=desc&per_page=100" \
        --jq '.items | group_by(.repository.full_name) | map({repo: .[0].repository.full_name, last_commit: .[0].commit.committer.date[:10]}) | .[] | "\(.repo)\t\(.last_commit)\torg"' 2>/dev/null >> "$REPOS_LIST"
done

# Get repos user has participated in (commits, PRs, issues) - catches public repos outside personal/org
echo "Checking repos you've participated in..." >&2

# Repos with user's commits (public repos)
gh api "search/commits?q=author:${USERNAME}+committer-date:>${DATE_FILTER}&sort=committer-date&order=desc&per_page=100" \
    --jq '.items | group_by(.repository.full_name) | map({repo: .[0].repository.full_name, last_commit: .[0].commit.committer.date[:10]}) | .[] | "\(.repo)\t\(.last_commit)\tcommits"' 2>/dev/null >> "$REPOS_LIST"

# Repos where user has opened PRs
gh api "search/issues?q=author:${USERNAME}+type:pr+created:>${DATE_FILTER}&sort=created&order=desc&per_page=100" \
    --jq '.items | group_by(.repository_url) | map({repo: (.[0].repository_url | split("/") | .[-2] + "/" + .[-1]), last_activity: .[0].created_at[:10]}) | .[] | "\(.repo)\t\(.last_activity)\tprs"' 2>/dev/null >> "$REPOS_LIST"

# Repos where user has reviewed PRs
gh api "search/issues?q=reviewed-by:${USERNAME}+type:pr+created:>${DATE_FILTER}&sort=created&order=desc&per_page=100" \
    --jq '.items | group_by(.repository_url) | map({repo: (.[0].repository_url | split("/") | .[-2] + "/" + .[-1]), last_activity: .[0].created_at[:10]}) | .[] | "\(.repo)\t\(.last_activity)\treviews"' 2>/dev/null >> "$REPOS_LIST"

# Check if we found any repos
if [[ ! -s "$REPOS_LIST" ]]; then
    echo "No repos found" >&2
    rm -f "$REPOS_LIST"
    exit 1
fi

# Load existing selections if any
EXISTING_REPOS=()
if [[ -f "$CONFIG_FILE" ]]; then
    while IFS= read -r repo; do
        [[ -n "$repo" ]] && EXISTING_REPOS+=("$repo")
    done < "$CONFIG_FILE"
fi

# Format for fzf display
# Sort by date descending, remove duplicates
FORMATTED=$(sort -t$'\t' -k2 -r "$REPOS_LIST" | awk -F'\t' '!seen[$1]++' | \
    awk -F'\t' '{printf "%-45s %s  %s\n", $1, $2, $3}')

rm -f "$REPOS_LIST"

# Separate already-selected repos from new ones
# Selected repos go first (will be pre-selected in fzf)
# Add visual marker [*] to already-selected repos
ALREADY_SELECTED=""
NOT_SELECTED=""
while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    repo=$(echo "$line" | awk '{print $1}')
    is_selected=false
    for existing in "${EXISTING_REPOS[@]}"; do
        if [[ "$repo" == "$existing" ]]; then
            is_selected=true
            break
        fi
    done
    if $is_selected; then
        ALREADY_SELECTED+="[*] $line"$'\n'
    else
        NOT_SELECTED+="    $line"$'\n'
    fi
done <<< "$FORMATTED"

# Remove trailing newline from ALREADY_SELECTED
ALREADY_SELECTED="${ALREADY_SELECTED%$'\n'}"

# Count selected repos for fzf toggle command
SELECTED_COUNT=0
if [[ -n "$ALREADY_SELECTED" ]]; then
    SELECTED_COUNT=$(echo "$ALREADY_SELECTED" | wc -l | xargs)
fi

# Combine: selected first, then not selected
if [[ -n "$ALREADY_SELECTED" ]] && [[ -n "$NOT_SELECTED" ]]; then
    COMBINED="${ALREADY_SELECTED}"$'\n'"${NOT_SELECTED}"
elif [[ -n "$ALREADY_SELECTED" ]]; then
    COMBINED="$ALREADY_SELECTED"
else
    COMBINED="$NOT_SELECTED"
fi
# Remove trailing newline
COMBINED="${COMBINED%$'\n'}"

echo "" >&2
echo "Select repos to watch for PRs (TAB to select, ENTER to confirm):" >&2
echo "[*] = currently selected" >&2

# Build fzf bind command to pre-select first N items (the already-selected ones)
FZF_LOAD_BIND=""
if [[ "$SELECTED_COUNT" -gt 0 ]]; then
    # Build a command like "toggle+down+toggle+down+..." then move back to top
    TOGGLE_CMDS=""
    for ((i=0; i<SELECTED_COUNT; i++)); do
        TOGGLE_CMDS+="toggle+down+"
    done
    # Remove trailing + and add first to go back to top
    TOGGLE_CMDS="${TOGGLE_CMDS%+}+first"
    FZF_LOAD_BIND="--bind=load:${TOGGLE_CMDS}"
fi

# Use fzf for multi-select
SELECTED=$(echo "$COMBINED" | fzf \
    --multi \
    --header="TAB: toggle | ENTER: confirm | ESC: cancel | [*] = currently selected" \
    --prompt="Select repos > " \
    --preview-window=hidden \
    --bind="ctrl-a:select-all" \
    --bind="ctrl-d:deselect-all" \
    $FZF_LOAD_BIND)

if [[ -z "$SELECTED" ]]; then
    echo "No repos selected, keeping existing config" >&2
    exit 0
fi

# Extract just repo names (skip the [*] or spaces prefix, get actual repo name)
# Format is: "[*] repo-name" or "    repo-name"
SELECTED_REPOS=$(echo "$SELECTED" | awk '{
    if ($1 == "[*]") print $2
    else print $1
}')

# Save to config file
mkdir -p "$CONFIG_DIR"
echo "$SELECTED_REPOS" > "$CONFIG_FILE"

COUNT=$(echo "$SELECTED_REPOS" | wc -l | xargs)
echo "" >&2
echo "Saved $COUNT repos to $CONFIG_FILE" >&2
echo "$SELECTED_REPOS"
